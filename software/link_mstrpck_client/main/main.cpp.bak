//// tdlf client // 16 touch pads // 16 leds // envoi des données de un array au client

//#include "driver/gpio.h"
#include "esp_event.h"
#include "esp_wifi.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "nvs_flash.h"
//#include "protocol_examples_common.h"
#include <ableton/Link.hpp>
#include <stdio.h>
#include "sdkconfig.h"

///////// TOUCH //////
#include "freertos/queue.h"
#include "esp_log.h"
#include "driver/touch_pad.h"
#include "soc/rtc_periph.h"
#include "soc/sens_periph.h"

///////// SOCKETTE ////////
#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include <lwip/netdb.h>

#define HOST_IP_ADDR "192.168.0.102" // synth is using a static ip
#define PORT 3333

////// sockette à rajouter /////static const char *payload = "Message from ESP32";

char rx_buffer[128];
char addr_str[128];
int addr_family;    
int ip_protocol;
struct sockaddr_in dest_addr;
int sock;

//// conversion tableau en byte ////
///////////////////////////byte result = 0;
///////////////////////////int index = 8;


///////// DELS /// SPI CONFIG TTGO // HSPI // HSPI MOSI 23 // HSPI SCK 18

extern "C"{ 
	#include <apa102.h> 
	}

//// LES TACHES //////
// tp_example_read_task (interrupt) touch pads
// link task (pinned to core 0) 
// appelle tick task // ableton link sur core 1



// Global

///// seq /////
bool bd[16] = {}; // empty 16 boolean values aray to store hits


static void periodic_timer_callback(void* arg);
esp_timer_handle_t periodic_timer;

bool startStopCB = false; // l'état du callback 
bool startStopState = false; // l'état local
bool changeLink = false;

int compteur = 0;
double curr_beat_time;
double prev_beat_time;

/////////////////// WiFI station example //////////////////////
extern "C"{
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
//#include "nvs_flash.h"
//#include "lwip/err.h"
//#include "lwip/sys.h"
}

extern "C" { 
#define EXAMPLE_ESP_WIFI_SSID      "link"
#define EXAMPLE_ESP_WIFI_PASS      "nidieunimaitre"
#define EXAMPLE_ESP_MAXIMUM_RETRY  2

static EventGroupHandle_t s_wifi_event_group;

#define WIFI_CONNECTED_BIT BIT0
#define WIFI_FAIL_BIT      BIT1
static const char *TAG = "tdlf client";

static int s_retry_num = 0;
}

extern "C" { 
static void event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data)
                                {
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        if (s_retry_num < EXAMPLE_ESP_MAXIMUM_RETRY) {
            esp_wifi_connect();
            s_retry_num++;
            ESP_LOGI(TAG, "retry to connect to the AP");
        } else {
            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);
        }
        ESP_LOGI(TAG,"connect to the AP fail");
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "got ip:" IPSTR, IP2STR(&event->ip_info.ip));
        s_retry_num = 0;
        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);
    }
}
} // fin de extern "C"

extern "C" { void wifi_init_sta(void)
{
    s_wifi_event_group = xEventGroupCreate();

    ESP_ERROR_CHECK(esp_netif_init());

    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_sta();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler, NULL));
    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler, NULL));

    
    ////
    wifi_config_t wifi_config = { // whatever parce que C, c'est pas C++
      { EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS }
      };

    /////
 
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) );
    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) );
    ESP_ERROR_CHECK(esp_wifi_start() );

    ESP_LOGI(TAG, "wifi_init_sta finished.");

    /* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum
     * number of re-tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */
    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,
            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,
            pdFALSE,
            pdFALSE,
            portMAX_DELAY);

    /* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually
     * happened. */
    if (bits & WIFI_CONNECTED_BIT) {
        ESP_LOGI(TAG, "connected to ap SSID:%s password:%s",
                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);
    } else if (bits & WIFI_FAIL_BIT) {
        ESP_LOGI(TAG, "Failed to connect to SSID:%s, password:%s",
                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);
    } else {
        ESP_LOGE(TAG, "UNEXPECTED EVENT");
    }

    /* The event will not be processed after unregister */
    //ESP_ERROR_CHECK(esp_event_handler_instance_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP, instance_got_ip));
    //ESP_ERROR_CHECK(esp_event_handler_instance_unregister(WIFI_EVENT, ESP_EVENT_ANY_ID, instance_any_id));
    //vEventGroupDelete(s_wifi_event_group);
}
} // fin de extern "C"


///// fin station example

// static const char *TAG = "Touch pad";

#define TOUCH_THRESH_NO_USE   (0)
#define TOUCH_THRESH_PERCENT  (90)
#define TOUCHPAD_FILTER_TOUCH_PERIOD (10)

static bool s_pad_activated[TOUCH_PAD_MAX];
static uint32_t s_pad_init_val[TOUCH_PAD_MAX];
////////////// TOUCH /////////


extern "C" {

bool flagTrue = 0;

void TurnLedOn(int compteur){
    printf("compteur : %d\n", compteur);
	
	if (!APA102.transaction.tx_buffer) // De LEDSTRIP.update();
	{
		APA102.transaction.tx_buffer = APA102.txbuffer;
	}

	spi_device_queue_trans(APA102.device, &APA102.transaction, portMAX_DELAY);
	
   // LEDSTRIP.leds[compteur-1] = RGBL(0x00, 0x00, 0x00, 0x00);

    //LEDSTRIP.leds[3] = RGBL(0xAA, 0xAA, 0x11, 0xAA);
    //LEDSTRIP.leds[compteur] = RGBL(0xAA, 0xAA, 0x11, 0xAA);


    for(int i = 0;i<16;i++){
		LEDSTRIP.leds[i] = RGBL(0x00, 0x00, 0x00, 0x00);	// tout off 
        if(i == compteur){
            if (bd[i]){
                
                LEDSTRIP.leds[i] = RGBL(0xBB, 0x00, 0x0BB, 0xBB); 
                }
            else{
                LEDSTRIP.leds[i] = RGBL(0xAA, 0xAA, 0x11, 0xAA);
                }
        }
		else if (bd[i]){
			LEDSTRIP.leds[i] = RGBL(0x11, 0x55, 0x11, 0x33);		
		}
	}


	spi_transaction_t* t;
	spi_device_get_trans_result(APA102.device, &t, portMAX_DELAY);

	//return ESP_OK; // retourne un warning / erreur lorsqu'activé
   
    
	
	vTaskDelay(100 / portTICK_PERIOD_MS); // 100 et 105 'fonctionnent'
	
}

////////// UDP SOCKETTE ////////
/*
static void udp_client_task(void *pvParameters)
{
    while (1) {

        while (1) {

            struct sockaddr_in source_addr; // Large enough for both IPv4 or IPv6
            socklen_t socklen = sizeof(source_addr);
            int len = recvfrom(sock, rx_buffer, sizeof(rx_buffer) - 1, 0, (struct sockaddr *)&source_addr, &socklen);

            // Error occurred during receiving
            if (len < 0) {
                ESP_LOGE(TAG, "recvfrom failed: errno %d", errno);
                break;
            } else { // Data received
                rx_buffer[len] = 0; // Null-terminate whatever we received and treat like a string
                ESP_LOGI(TAG, "Received %d bytes from %s:", len, addr_str);
                ESP_LOGI(TAG, "%s", rx_buffer);

                // control leds from pd (udp)
                
                if(rx_buffer[0] == '1') { // looper number (exclusive so managed here)
                  ESP_LOGI(TAG, "succès UDP");
                } 
            }

            vTaskDelay(500 / portTICK_PERIOD_MS);
        }

        if (sock != -1) {
            ESP_LOGE(TAG, "Shutting down socket and restarting...");
            shutdown(sock, 0);
            close(sock);
        }
    }
    vTaskDelete(NULL);
}
*/

////////// TOUCH ///////////
static void tp_example_set_thresholds(void)
{
    uint16_t touch_value;
    for (int i = 0; i < TOUCH_PAD_MAX; i++) {
        //read filtered value
        touch_pad_read_filtered((touch_pad_t)i, &touch_value);
        s_pad_init_val[i] = touch_value;
        ESP_LOGI(TAG, "test init: touch pad [%d] val is %d", i, touch_value);
        //set interrupt threshold.
        ESP_ERROR_CHECK(touch_pad_set_thresh((touch_pad_t)i, touch_value * 2 / 3));
    }
}


static void tp_example_read_task(void *pvParameter)
{
    static int show_message;
    int change_mode = 0;
    int filter_mode = 0;

    while (1) {
        if (filter_mode == 0) {
            //interrupt mode, enable touch interrupt
            touch_pad_intr_enable();
            for (int i = 0; i < TOUCH_PAD_MAX; i++) {
                if (s_pad_activated[i] == true) {

                /// logique ici
                if(s_pad_activated[2] && s_pad_activated[4]){
                    ESP_LOGI(TAG, "piton 1");
                    bd[0] = !bd[0];
                        }
                if(s_pad_activated[0] && s_pad_activated[4]){
                    ESP_LOGI(TAG, "piton 2");
                    bd[1] = !bd[1];
                        }
                if(s_pad_activated[3] && s_pad_activated[4]){
                    ESP_LOGI(TAG, "piton 3");
                    bd[2] = !bd[2];
                        }
                if(s_pad_activated[9] && s_pad_activated[4]){
                    ESP_LOGI(TAG, "piton 4");
                    bd[3] = !bd[3];
                        }
                /////// 5-8
                if(s_pad_activated[2] && s_pad_activated[5]){
                            ESP_LOGI(TAG, "piton 5");
                            bd[4] = !bd[4];
                                }
                if(s_pad_activated[0] && s_pad_activated[5]){
                            ESP_LOGI(TAG, "piton 6");
                            bd[5] = !bd[5];
                                }
                if(s_pad_activated[3] && s_pad_activated[5]){
                            ESP_LOGI(TAG, "piton 7");
                            bd[6] = !bd[6];
                                }
                if(s_pad_activated[9] && s_pad_activated[5]){
                            ESP_LOGI(TAG, "piton 8");
                            bd[7] = !bd[7];
                                }
                /////// 9-12
                if(s_pad_activated[2] && s_pad_activated[6]){
                        ESP_LOGI(TAG, "piton 9");
                        bd[8] = !bd[8];
                            }
                if(s_pad_activated[0] && s_pad_activated[6]){
                        ESP_LOGI(TAG, "piton 10");
                        bd[9] = !bd[9];
                            }
                if(s_pad_activated[3] && s_pad_activated[6]){
                        ESP_LOGI(TAG, "piton 11");
                        bd[10] = !bd[10];
                            }
                if(s_pad_activated[9] && s_pad_activated[6]){
                        ESP_LOGI(TAG, "piton 12");
                        bd[11] = !bd[11];
                            }
                /////// 13-16
                if(s_pad_activated[2] && s_pad_activated[7]){
                      ESP_LOGI(TAG, "piton 13");
                      bd[12] = !bd[12];
                          }
                if(s_pad_activated[0] && s_pad_activated[7]){
                      ESP_LOGI(TAG, "piton 14");
                      bd[13] = !bd[13];
                          }
                if(s_pad_activated[3] && s_pad_activated[7]){
                      ESP_LOGI(TAG, "piton 15");
                      bd[14] = !bd[14];
                          }
                if(s_pad_activated[9] && s_pad_activated[7]){
                      ESP_LOGI(TAG, "piton 16");
                      bd[15] = !bd[15];
                          }

                    ESP_LOGI(TAG, "T%d activated!", i);
					
                    vTaskDelay(100 / portTICK_PERIOD_MS); // Wait a while for the pad being released
                    s_pad_activated[i] = false; // Clear information on pad activation
                    show_message = 1;  /// // Reset the counter triggering a message that application is running
                }
            }
        }

        vTaskDelay(10 / portTICK_PERIOD_MS);

    }
}


static void tp_example_rtc_intr(void *arg)
{
    uint32_t pad_intr = touch_pad_get_status();
    //clear interrupt
    touch_pad_clear_status();
    for (int i = 0; i < TOUCH_PAD_MAX; i++) {
        if ((pad_intr >> i) & 0x01) {
            s_pad_activated[i] = true;
        }
    }
}

/*
 * Before reading touch pad, we need to initialize the RTC IO.
 */
static void tp_example_touch_pad_init(void)
{
    for (int i = 0; i < TOUCH_PAD_MAX; i++) {
        //init RTC IO and mode for touch pad.
        touch_pad_config((touch_pad_t)i, TOUCH_THRESH_NO_USE);
    }
}

///////// FIN TOUCH //////////


} // fin de extern "C"


unsigned int if_nametoindex(const char* ifname)
{
  return 0;
}

char* if_indextoname(unsigned int ifindex, char* ifname)
{
  return nullptr;
}

// callbacks
void tempoChanged(double tempo) {
    ESP_LOGI(TAG, "tempochanged");
    double midiClockMicroSecond = ((60000 / tempo) / 24) * 1000;
    esp_timer_handle_t periodic_timer_handle = (esp_timer_handle_t) periodic_timer;
    ESP_ERROR_CHECK(esp_timer_stop(periodic_timer_handle));
    ESP_ERROR_CHECK(esp_timer_start_periodic(periodic_timer_handle, midiClockMicroSecond));
}

void startStopChanged(bool state) {   // received as soon as sent, we can get the state of 'isPlaying' and use that
  startStopCB = state;  // need to wait for phase to be 0 (and deal with latency...)
  changeLink = true;
}

void tickTask(void* userParam)
{

	// ESP_LOGI(TAG, "on se rend ici link enabled ! ");

	// xTaskCreatePinnedToCore(
	//	tickTask, "tickTask", 8192, static_cast<void*>(&link), 10, nullptr, 1); // sur core 1

  	//while (true)
  	//{
    //	vTaskDelay(portMAX_DELAY);
  	//}
    //}

    // connect link
    ableton::Link link(120.0f);
    link.enable(true);
    link.enableStartStopSync(true); // if not no callback for start/stop
    
    // callbacks
    link.setTempoCallback(tempoChanged);
    link.setStartStopCallback(startStopChanged);

    //auto pLink = static_cast<ableton::Link*>(user_param);
    
    while (true)
    {
        xSemaphoreTake(userParam, portMAX_DELAY);

        const auto state = link.captureAudioSessionState();
        curr_beat_time = state.beatAtTime(link.clock().micros(), 4);
        const double curr_phase = fmod(curr_beat_time, 4);
        
        if (curr_beat_time > prev_beat_time) {

            const double prev_phase = fmod(prev_beat_time, 4);
            const double prev_step = floor(prev_phase * 1);
            const double curr_step = floor(curr_phase * 1);
            ESP_LOGI(TAG, "current step : %f", curr_step); 
            ESP_LOGI(TAG, "prev step : %f", prev_step); 
            ESP_LOGI(TAG, "curr_phase : %f", curr_phase); 

            if (abs(curr_step - prev_step) > 0.5){
      
                ESP_LOGI(TAG, "compteur %d", compteur); 
                char buf[10];
                char compte[10];
                TurnLedOn(compteur); // ok il reste à allumer les DELs à partir de ça	
                compteur = compteur + 1;
	            compteur = compteur % 16;	
            }

/*

if (yep == true && flagTrue == false)
	{

	// envoi le tableau du BD au serveur (la sockette)

	//sendto(sock, payload, strlen(payload), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));
	
    flagTrue = !flagTrue;
    }
else if (yep == false && flagTrue == true) {
    flagTrue = !flagTrue;
	}
    */
	vTaskDelay(20 / portTICK_PERIOD_MS);
  }
		

} // fin de tickTask




extern "C" void app_main()
{
    esp_err_t ret = nvs_flash_init();   //Initialize NVS
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    ESP_LOGI(TAG, "ESP_WIFI_MODE_STA");
    wifi_init_sta();

  	//esp_wifi_set_ps(WIFI_PS_NONE);

	LEDSTRIP.init(16); // arg est le nombre de LEDs
	

	/////// TOUCH INIT ////////

	ESP_LOGI(TAG, "Initializing touch pad");
	touch_pad_init(); // Initialize touch pad peripheral, it will start a timer to run a filter
	touch_pad_set_fsm_mode(TOUCH_FSM_MODE_TIMER); // If use interrupt trigger mode, should set touch sensor FSM mode at 'TOUCH_FSM_MODE_TIMER'.
	touch_pad_set_voltage(TOUCH_HVOLT_2V7, TOUCH_LVOLT_0V5, TOUCH_HVOLT_ATTEN_1V); // Set reference voltage for charging/discharging // For most usage scenarios, we recommend using the following combination: // the high reference valtage will be 2.7V - 1V = 1.7V, The low reference voltage will be 0.5V.
	tp_example_touch_pad_init(); // Init touch pad IO
	touch_pad_filter_start(TOUCHPAD_FILTER_TOUCH_PERIOD); // Initialize and start a software filter to detect slight change of capacitance.
	tp_example_set_thresholds(); // Set thresh hold
	touch_pad_isr_register(tp_example_rtc_intr, NULL); // Register touch interrupt ISR

	////////// TOUCH TASK //////////// // Start a task to show what pads have been touched
	xTaskCreate(&tp_example_read_task, "touch_pad_read_task", 2048, NULL, 5, NULL); // n'importe quelle core
	///////// FIN TOUCH /////////

	/*
	///// SOCKETTE TASK //////
	// upd init + timer

	dest_addr.sin_addr.s_addr = inet_addr(HOST_IP_ADDR); //  "192.168.0.102"
	dest_addr.sin_family = AF_INET;
	dest_addr.sin_port = htons(PORT); // "3333"	
	addr_family = AF_INET;
	ip_protocol = IPPROTO_IP;
  	inet_ntoa_r(dest_addr.sin_addr, addr_str, sizeof(addr_str) - 1);
 	sock = socket(addr_family, SOCK_DGRAM, ip_protocol);
  	if (sock < 0) {
    	ESP_LOGE(TAG, "Unable to create socket: errno %d", errno);
  		}
  	ESP_LOGI(TAG, "Socket created, sending to %s:%d", HOST_IP_ADDR, PORT);

	/////////  xTaskCreate(udp_client_task, "udp_client", 4096, NULL, 5, NULL);
	///// FIN SOCKETTE /////
	*/

	// ---> TaskCreatePinnedToCore(link_task, "link_task", 8192, nullptr, 10, nullptr, 0);  // core 0
	
     // link timer - phase
    SemaphoreHandle_t tickSemphr = xSemaphoreCreateBinary();
    timerGroup0Init(1000, tickSemphr);
    xTaskCreate(tickTask, "tick", 8192, tickSemphr, 1, nullptr);

	ESP_LOGI(TAG, "on se rend ici, après link task ! ");

	vTaskDelete(nullptr);

} // fin du extern "C"
